
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `Path` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Path
 * 
 */
export type PathModel = runtime.Types.Result.DefaultSelection<Prisma.$PathPayload>

export type AggregatePath = {
  _count: PathCountAggregateOutputType | null
  _min: PathMinAggregateOutputType | null
  _max: PathMaxAggregateOutputType | null
}

export type PathMinAggregateOutputType = {
  id: string | null
  fromRoomId: string | null
  toRoomId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PathMaxAggregateOutputType = {
  id: string | null
  fromRoomId: string | null
  toRoomId: string | null
  createdAt: Date | null
  updatedAt: Date | null
}

export type PathCountAggregateOutputType = {
  id: number
  fromRoomId: number
  toRoomId: number
  createdAt: number
  updatedAt: number
  _all: number
}


export type PathMinAggregateInputType = {
  id?: true
  fromRoomId?: true
  toRoomId?: true
  createdAt?: true
  updatedAt?: true
}

export type PathMaxAggregateInputType = {
  id?: true
  fromRoomId?: true
  toRoomId?: true
  createdAt?: true
  updatedAt?: true
}

export type PathCountAggregateInputType = {
  id?: true
  fromRoomId?: true
  toRoomId?: true
  createdAt?: true
  updatedAt?: true
  _all?: true
}

export type PathAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Path to aggregate.
   */
  where?: Prisma.PathWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Paths to fetch.
   */
  orderBy?: Prisma.PathOrderByWithRelationInput | Prisma.PathOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.PathWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Paths from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Paths.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Paths
  **/
  _count?: true | PathCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PathMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PathMaxAggregateInputType
}

export type GetPathAggregateType<T extends PathAggregateArgs> = {
      [P in keyof T & keyof AggregatePath]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePath[P]>
    : Prisma.GetScalarType<T[P], AggregatePath[P]>
}




export type PathGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PathWhereInput
  orderBy?: Prisma.PathOrderByWithAggregationInput | Prisma.PathOrderByWithAggregationInput[]
  by: Prisma.PathScalarFieldEnum[] | Prisma.PathScalarFieldEnum
  having?: Prisma.PathScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PathCountAggregateInputType | true
  _min?: PathMinAggregateInputType
  _max?: PathMaxAggregateInputType
}

export type PathGroupByOutputType = {
  id: string
  fromRoomId: string
  toRoomId: string
  createdAt: Date
  updatedAt: Date
  _count: PathCountAggregateOutputType | null
  _min: PathMinAggregateOutputType | null
  _max: PathMaxAggregateOutputType | null
}

type GetPathGroupByPayload<T extends PathGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PathGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PathGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PathGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PathGroupByOutputType[P]>
      }
    >
  >



export type PathWhereInput = {
  AND?: Prisma.PathWhereInput | Prisma.PathWhereInput[]
  OR?: Prisma.PathWhereInput[]
  NOT?: Prisma.PathWhereInput | Prisma.PathWhereInput[]
  id?: Prisma.StringFilter<"Path"> | string
  fromRoomId?: Prisma.StringFilter<"Path"> | string
  toRoomId?: Prisma.StringFilter<"Path"> | string
  createdAt?: Prisma.DateTimeFilter<"Path"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Path"> | Date | string
  fromRoom?: Prisma.XOR<Prisma.RoomScalarRelationFilter, Prisma.RoomWhereInput>
  toRoom?: Prisma.XOR<Prisma.RoomScalarRelationFilter, Prisma.RoomWhereInput>
  instructionSet?: Prisma.XOR<Prisma.InstructionSetNullableScalarRelationFilter, Prisma.InstructionSetWhereInput> | null
  anchors?: Prisma.PathAnchorListRelationFilter
}

export type PathOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  fromRoomId?: Prisma.SortOrder
  toRoomId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  fromRoom?: Prisma.RoomOrderByWithRelationInput
  toRoom?: Prisma.RoomOrderByWithRelationInput
  instructionSet?: Prisma.InstructionSetOrderByWithRelationInput
  anchors?: Prisma.PathAnchorOrderByRelationAggregateInput
}

export type PathWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.PathWhereInput | Prisma.PathWhereInput[]
  OR?: Prisma.PathWhereInput[]
  NOT?: Prisma.PathWhereInput | Prisma.PathWhereInput[]
  fromRoomId?: Prisma.StringFilter<"Path"> | string
  toRoomId?: Prisma.StringFilter<"Path"> | string
  createdAt?: Prisma.DateTimeFilter<"Path"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Path"> | Date | string
  fromRoom?: Prisma.XOR<Prisma.RoomScalarRelationFilter, Prisma.RoomWhereInput>
  toRoom?: Prisma.XOR<Prisma.RoomScalarRelationFilter, Prisma.RoomWhereInput>
  instructionSet?: Prisma.XOR<Prisma.InstructionSetNullableScalarRelationFilter, Prisma.InstructionSetWhereInput> | null
  anchors?: Prisma.PathAnchorListRelationFilter
}, "id">

export type PathOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  fromRoomId?: Prisma.SortOrder
  toRoomId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  _count?: Prisma.PathCountOrderByAggregateInput
  _max?: Prisma.PathMaxOrderByAggregateInput
  _min?: Prisma.PathMinOrderByAggregateInput
}

export type PathScalarWhereWithAggregatesInput = {
  AND?: Prisma.PathScalarWhereWithAggregatesInput | Prisma.PathScalarWhereWithAggregatesInput[]
  OR?: Prisma.PathScalarWhereWithAggregatesInput[]
  NOT?: Prisma.PathScalarWhereWithAggregatesInput | Prisma.PathScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Path"> | string
  fromRoomId?: Prisma.StringWithAggregatesFilter<"Path"> | string
  toRoomId?: Prisma.StringWithAggregatesFilter<"Path"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Path"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Path"> | Date | string
}

export type PathCreateInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  fromRoom: Prisma.RoomCreateNestedOneWithoutFromPathsInput
  toRoom: Prisma.RoomCreateNestedOneWithoutToPathsInput
  instructionSet?: Prisma.InstructionSetCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorCreateNestedManyWithoutPathInput
}

export type PathUncheckedCreateInput = {
  id?: string
  fromRoomId: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
  instructionSet?: Prisma.InstructionSetUncheckedCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorUncheckedCreateNestedManyWithoutPathInput
}

export type PathUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  fromRoom?: Prisma.RoomUpdateOneRequiredWithoutFromPathsNestedInput
  toRoom?: Prisma.RoomUpdateOneRequiredWithoutToPathsNestedInput
  instructionSet?: Prisma.InstructionSetUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  instructionSet?: Prisma.InstructionSetUncheckedUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUncheckedUpdateManyWithoutPathNestedInput
}

export type PathCreateManyInput = {
  id?: string
  fromRoomId: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PathUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PathUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PathListRelationFilter = {
  every?: Prisma.PathWhereInput
  some?: Prisma.PathWhereInput
  none?: Prisma.PathWhereInput
}

export type PathOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type PathCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  fromRoomId?: Prisma.SortOrder
  toRoomId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PathMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  fromRoomId?: Prisma.SortOrder
  toRoomId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PathMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  fromRoomId?: Prisma.SortOrder
  toRoomId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
}

export type PathScalarRelationFilter = {
  is?: Prisma.PathWhereInput
  isNot?: Prisma.PathWhereInput
}

export type PathCreateNestedManyWithoutFromRoomInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput> | Prisma.PathCreateWithoutFromRoomInput[] | Prisma.PathUncheckedCreateWithoutFromRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutFromRoomInput | Prisma.PathCreateOrConnectWithoutFromRoomInput[]
  createMany?: Prisma.PathCreateManyFromRoomInputEnvelope
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
}

export type PathCreateNestedManyWithoutToRoomInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput> | Prisma.PathCreateWithoutToRoomInput[] | Prisma.PathUncheckedCreateWithoutToRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutToRoomInput | Prisma.PathCreateOrConnectWithoutToRoomInput[]
  createMany?: Prisma.PathCreateManyToRoomInputEnvelope
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
}

export type PathUncheckedCreateNestedManyWithoutFromRoomInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput> | Prisma.PathCreateWithoutFromRoomInput[] | Prisma.PathUncheckedCreateWithoutFromRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutFromRoomInput | Prisma.PathCreateOrConnectWithoutFromRoomInput[]
  createMany?: Prisma.PathCreateManyFromRoomInputEnvelope
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
}

export type PathUncheckedCreateNestedManyWithoutToRoomInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput> | Prisma.PathCreateWithoutToRoomInput[] | Prisma.PathUncheckedCreateWithoutToRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutToRoomInput | Prisma.PathCreateOrConnectWithoutToRoomInput[]
  createMany?: Prisma.PathCreateManyToRoomInputEnvelope
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
}

export type PathUpdateManyWithoutFromRoomNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput> | Prisma.PathCreateWithoutFromRoomInput[] | Prisma.PathUncheckedCreateWithoutFromRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutFromRoomInput | Prisma.PathCreateOrConnectWithoutFromRoomInput[]
  upsert?: Prisma.PathUpsertWithWhereUniqueWithoutFromRoomInput | Prisma.PathUpsertWithWhereUniqueWithoutFromRoomInput[]
  createMany?: Prisma.PathCreateManyFromRoomInputEnvelope
  set?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  disconnect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  delete?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  update?: Prisma.PathUpdateWithWhereUniqueWithoutFromRoomInput | Prisma.PathUpdateWithWhereUniqueWithoutFromRoomInput[]
  updateMany?: Prisma.PathUpdateManyWithWhereWithoutFromRoomInput | Prisma.PathUpdateManyWithWhereWithoutFromRoomInput[]
  deleteMany?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
}

export type PathUpdateManyWithoutToRoomNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput> | Prisma.PathCreateWithoutToRoomInput[] | Prisma.PathUncheckedCreateWithoutToRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutToRoomInput | Prisma.PathCreateOrConnectWithoutToRoomInput[]
  upsert?: Prisma.PathUpsertWithWhereUniqueWithoutToRoomInput | Prisma.PathUpsertWithWhereUniqueWithoutToRoomInput[]
  createMany?: Prisma.PathCreateManyToRoomInputEnvelope
  set?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  disconnect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  delete?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  update?: Prisma.PathUpdateWithWhereUniqueWithoutToRoomInput | Prisma.PathUpdateWithWhereUniqueWithoutToRoomInput[]
  updateMany?: Prisma.PathUpdateManyWithWhereWithoutToRoomInput | Prisma.PathUpdateManyWithWhereWithoutToRoomInput[]
  deleteMany?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
}

export type PathUncheckedUpdateManyWithoutFromRoomNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput> | Prisma.PathCreateWithoutFromRoomInput[] | Prisma.PathUncheckedCreateWithoutFromRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutFromRoomInput | Prisma.PathCreateOrConnectWithoutFromRoomInput[]
  upsert?: Prisma.PathUpsertWithWhereUniqueWithoutFromRoomInput | Prisma.PathUpsertWithWhereUniqueWithoutFromRoomInput[]
  createMany?: Prisma.PathCreateManyFromRoomInputEnvelope
  set?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  disconnect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  delete?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  update?: Prisma.PathUpdateWithWhereUniqueWithoutFromRoomInput | Prisma.PathUpdateWithWhereUniqueWithoutFromRoomInput[]
  updateMany?: Prisma.PathUpdateManyWithWhereWithoutFromRoomInput | Prisma.PathUpdateManyWithWhereWithoutFromRoomInput[]
  deleteMany?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
}

export type PathUncheckedUpdateManyWithoutToRoomNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput> | Prisma.PathCreateWithoutToRoomInput[] | Prisma.PathUncheckedCreateWithoutToRoomInput[]
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutToRoomInput | Prisma.PathCreateOrConnectWithoutToRoomInput[]
  upsert?: Prisma.PathUpsertWithWhereUniqueWithoutToRoomInput | Prisma.PathUpsertWithWhereUniqueWithoutToRoomInput[]
  createMany?: Prisma.PathCreateManyToRoomInputEnvelope
  set?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  disconnect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  delete?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  connect?: Prisma.PathWhereUniqueInput | Prisma.PathWhereUniqueInput[]
  update?: Prisma.PathUpdateWithWhereUniqueWithoutToRoomInput | Prisma.PathUpdateWithWhereUniqueWithoutToRoomInput[]
  updateMany?: Prisma.PathUpdateManyWithWhereWithoutToRoomInput | Prisma.PathUpdateManyWithWhereWithoutToRoomInput[]
  deleteMany?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
}

export type PathCreateNestedOneWithoutInstructionSetInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutInstructionSetInput, Prisma.PathUncheckedCreateWithoutInstructionSetInput>
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutInstructionSetInput
  connect?: Prisma.PathWhereUniqueInput
}

export type PathUpdateOneRequiredWithoutInstructionSetNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutInstructionSetInput, Prisma.PathUncheckedCreateWithoutInstructionSetInput>
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutInstructionSetInput
  upsert?: Prisma.PathUpsertWithoutInstructionSetInput
  connect?: Prisma.PathWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PathUpdateToOneWithWhereWithoutInstructionSetInput, Prisma.PathUpdateWithoutInstructionSetInput>, Prisma.PathUncheckedUpdateWithoutInstructionSetInput>
}

export type PathCreateNestedOneWithoutAnchorsInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutAnchorsInput, Prisma.PathUncheckedCreateWithoutAnchorsInput>
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutAnchorsInput
  connect?: Prisma.PathWhereUniqueInput
}

export type PathUpdateOneRequiredWithoutAnchorsNestedInput = {
  create?: Prisma.XOR<Prisma.PathCreateWithoutAnchorsInput, Prisma.PathUncheckedCreateWithoutAnchorsInput>
  connectOrCreate?: Prisma.PathCreateOrConnectWithoutAnchorsInput
  upsert?: Prisma.PathUpsertWithoutAnchorsInput
  connect?: Prisma.PathWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.PathUpdateToOneWithWhereWithoutAnchorsInput, Prisma.PathUpdateWithoutAnchorsInput>, Prisma.PathUncheckedUpdateWithoutAnchorsInput>
}

export type PathCreateWithoutFromRoomInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  toRoom: Prisma.RoomCreateNestedOneWithoutToPathsInput
  instructionSet?: Prisma.InstructionSetCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorCreateNestedManyWithoutPathInput
}

export type PathUncheckedCreateWithoutFromRoomInput = {
  id?: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
  instructionSet?: Prisma.InstructionSetUncheckedCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorUncheckedCreateNestedManyWithoutPathInput
}

export type PathCreateOrConnectWithoutFromRoomInput = {
  where: Prisma.PathWhereUniqueInput
  create: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput>
}

export type PathCreateManyFromRoomInputEnvelope = {
  data: Prisma.PathCreateManyFromRoomInput | Prisma.PathCreateManyFromRoomInput[]
  skipDuplicates?: boolean
}

export type PathCreateWithoutToRoomInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  fromRoom: Prisma.RoomCreateNestedOneWithoutFromPathsInput
  instructionSet?: Prisma.InstructionSetCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorCreateNestedManyWithoutPathInput
}

export type PathUncheckedCreateWithoutToRoomInput = {
  id?: string
  fromRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
  instructionSet?: Prisma.InstructionSetUncheckedCreateNestedOneWithoutPathInput
  anchors?: Prisma.PathAnchorUncheckedCreateNestedManyWithoutPathInput
}

export type PathCreateOrConnectWithoutToRoomInput = {
  where: Prisma.PathWhereUniqueInput
  create: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput>
}

export type PathCreateManyToRoomInputEnvelope = {
  data: Prisma.PathCreateManyToRoomInput | Prisma.PathCreateManyToRoomInput[]
  skipDuplicates?: boolean
}

export type PathUpsertWithWhereUniqueWithoutFromRoomInput = {
  where: Prisma.PathWhereUniqueInput
  update: Prisma.XOR<Prisma.PathUpdateWithoutFromRoomInput, Prisma.PathUncheckedUpdateWithoutFromRoomInput>
  create: Prisma.XOR<Prisma.PathCreateWithoutFromRoomInput, Prisma.PathUncheckedCreateWithoutFromRoomInput>
}

export type PathUpdateWithWhereUniqueWithoutFromRoomInput = {
  where: Prisma.PathWhereUniqueInput
  data: Prisma.XOR<Prisma.PathUpdateWithoutFromRoomInput, Prisma.PathUncheckedUpdateWithoutFromRoomInput>
}

export type PathUpdateManyWithWhereWithoutFromRoomInput = {
  where: Prisma.PathScalarWhereInput
  data: Prisma.XOR<Prisma.PathUpdateManyMutationInput, Prisma.PathUncheckedUpdateManyWithoutFromRoomInput>
}

export type PathScalarWhereInput = {
  AND?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
  OR?: Prisma.PathScalarWhereInput[]
  NOT?: Prisma.PathScalarWhereInput | Prisma.PathScalarWhereInput[]
  id?: Prisma.StringFilter<"Path"> | string
  fromRoomId?: Prisma.StringFilter<"Path"> | string
  toRoomId?: Prisma.StringFilter<"Path"> | string
  createdAt?: Prisma.DateTimeFilter<"Path"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Path"> | Date | string
}

export type PathUpsertWithWhereUniqueWithoutToRoomInput = {
  where: Prisma.PathWhereUniqueInput
  update: Prisma.XOR<Prisma.PathUpdateWithoutToRoomInput, Prisma.PathUncheckedUpdateWithoutToRoomInput>
  create: Prisma.XOR<Prisma.PathCreateWithoutToRoomInput, Prisma.PathUncheckedCreateWithoutToRoomInput>
}

export type PathUpdateWithWhereUniqueWithoutToRoomInput = {
  where: Prisma.PathWhereUniqueInput
  data: Prisma.XOR<Prisma.PathUpdateWithoutToRoomInput, Prisma.PathUncheckedUpdateWithoutToRoomInput>
}

export type PathUpdateManyWithWhereWithoutToRoomInput = {
  where: Prisma.PathScalarWhereInput
  data: Prisma.XOR<Prisma.PathUpdateManyMutationInput, Prisma.PathUncheckedUpdateManyWithoutToRoomInput>
}

export type PathCreateWithoutInstructionSetInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  fromRoom: Prisma.RoomCreateNestedOneWithoutFromPathsInput
  toRoom: Prisma.RoomCreateNestedOneWithoutToPathsInput
  anchors?: Prisma.PathAnchorCreateNestedManyWithoutPathInput
}

export type PathUncheckedCreateWithoutInstructionSetInput = {
  id?: string
  fromRoomId: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
  anchors?: Prisma.PathAnchorUncheckedCreateNestedManyWithoutPathInput
}

export type PathCreateOrConnectWithoutInstructionSetInput = {
  where: Prisma.PathWhereUniqueInput
  create: Prisma.XOR<Prisma.PathCreateWithoutInstructionSetInput, Prisma.PathUncheckedCreateWithoutInstructionSetInput>
}

export type PathUpsertWithoutInstructionSetInput = {
  update: Prisma.XOR<Prisma.PathUpdateWithoutInstructionSetInput, Prisma.PathUncheckedUpdateWithoutInstructionSetInput>
  create: Prisma.XOR<Prisma.PathCreateWithoutInstructionSetInput, Prisma.PathUncheckedCreateWithoutInstructionSetInput>
  where?: Prisma.PathWhereInput
}

export type PathUpdateToOneWithWhereWithoutInstructionSetInput = {
  where?: Prisma.PathWhereInput
  data: Prisma.XOR<Prisma.PathUpdateWithoutInstructionSetInput, Prisma.PathUncheckedUpdateWithoutInstructionSetInput>
}

export type PathUpdateWithoutInstructionSetInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  fromRoom?: Prisma.RoomUpdateOneRequiredWithoutFromPathsNestedInput
  toRoom?: Prisma.RoomUpdateOneRequiredWithoutToPathsNestedInput
  anchors?: Prisma.PathAnchorUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateWithoutInstructionSetInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  anchors?: Prisma.PathAnchorUncheckedUpdateManyWithoutPathNestedInput
}

export type PathCreateWithoutAnchorsInput = {
  id?: string
  createdAt?: Date | string
  updatedAt?: Date | string
  fromRoom: Prisma.RoomCreateNestedOneWithoutFromPathsInput
  toRoom: Prisma.RoomCreateNestedOneWithoutToPathsInput
  instructionSet?: Prisma.InstructionSetCreateNestedOneWithoutPathInput
}

export type PathUncheckedCreateWithoutAnchorsInput = {
  id?: string
  fromRoomId: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
  instructionSet?: Prisma.InstructionSetUncheckedCreateNestedOneWithoutPathInput
}

export type PathCreateOrConnectWithoutAnchorsInput = {
  where: Prisma.PathWhereUniqueInput
  create: Prisma.XOR<Prisma.PathCreateWithoutAnchorsInput, Prisma.PathUncheckedCreateWithoutAnchorsInput>
}

export type PathUpsertWithoutAnchorsInput = {
  update: Prisma.XOR<Prisma.PathUpdateWithoutAnchorsInput, Prisma.PathUncheckedUpdateWithoutAnchorsInput>
  create: Prisma.XOR<Prisma.PathCreateWithoutAnchorsInput, Prisma.PathUncheckedCreateWithoutAnchorsInput>
  where?: Prisma.PathWhereInput
}

export type PathUpdateToOneWithWhereWithoutAnchorsInput = {
  where?: Prisma.PathWhereInput
  data: Prisma.XOR<Prisma.PathUpdateWithoutAnchorsInput, Prisma.PathUncheckedUpdateWithoutAnchorsInput>
}

export type PathUpdateWithoutAnchorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  fromRoom?: Prisma.RoomUpdateOneRequiredWithoutFromPathsNestedInput
  toRoom?: Prisma.RoomUpdateOneRequiredWithoutToPathsNestedInput
  instructionSet?: Prisma.InstructionSetUpdateOneWithoutPathNestedInput
}

export type PathUncheckedUpdateWithoutAnchorsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  instructionSet?: Prisma.InstructionSetUncheckedUpdateOneWithoutPathNestedInput
}

export type PathCreateManyFromRoomInput = {
  id?: string
  toRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PathCreateManyToRoomInput = {
  id?: string
  fromRoomId: string
  createdAt?: Date | string
  updatedAt?: Date | string
}

export type PathUpdateWithoutFromRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  toRoom?: Prisma.RoomUpdateOneRequiredWithoutToPathsNestedInput
  instructionSet?: Prisma.InstructionSetUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateWithoutFromRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  instructionSet?: Prisma.InstructionSetUncheckedUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUncheckedUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateManyWithoutFromRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  toRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type PathUpdateWithoutToRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  fromRoom?: Prisma.RoomUpdateOneRequiredWithoutFromPathsNestedInput
  instructionSet?: Prisma.InstructionSetUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateWithoutToRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  instructionSet?: Prisma.InstructionSetUncheckedUpdateOneWithoutPathNestedInput
  anchors?: Prisma.PathAnchorUncheckedUpdateManyWithoutPathNestedInput
}

export type PathUncheckedUpdateManyWithoutToRoomInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  fromRoomId?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type PathCountOutputType
 */

export type PathCountOutputType = {
  anchors: number
}

export type PathCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  anchors?: boolean | PathCountOutputTypeCountAnchorsArgs
}

/**
 * PathCountOutputType without action
 */
export type PathCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PathCountOutputType
   */
  select?: Prisma.PathCountOutputTypeSelect<ExtArgs> | null
}

/**
 * PathCountOutputType without action
 */
export type PathCountOutputTypeCountAnchorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.PathAnchorWhereInput
}


export type PathSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  fromRoomId?: boolean
  toRoomId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  instructionSet?: boolean | Prisma.Path$instructionSetArgs<ExtArgs>
  anchors?: boolean | Prisma.Path$anchorsArgs<ExtArgs>
  _count?: boolean | Prisma.PathCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["path"]>

export type PathSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  fromRoomId?: boolean
  toRoomId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
}, ExtArgs["result"]["path"]>

export type PathSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  fromRoomId?: boolean
  toRoomId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
}, ExtArgs["result"]["path"]>

export type PathSelectScalar = {
  id?: boolean
  fromRoomId?: boolean
  toRoomId?: boolean
  createdAt?: boolean
  updatedAt?: boolean
}

export type PathOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "fromRoomId" | "toRoomId" | "createdAt" | "updatedAt", ExtArgs["result"]["path"]>
export type PathInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  instructionSet?: boolean | Prisma.Path$instructionSetArgs<ExtArgs>
  anchors?: boolean | Prisma.Path$anchorsArgs<ExtArgs>
  _count?: boolean | Prisma.PathCountOutputTypeDefaultArgs<ExtArgs>
}
export type PathIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
}
export type PathIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  fromRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
  toRoom?: boolean | Prisma.RoomDefaultArgs<ExtArgs>
}

export type $PathPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Path"
  objects: {
    fromRoom: Prisma.$RoomPayload<ExtArgs>
    toRoom: Prisma.$RoomPayload<ExtArgs>
    instructionSet: Prisma.$InstructionSetPayload<ExtArgs> | null
    anchors: Prisma.$PathAnchorPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    fromRoomId: string
    toRoomId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["path"]>
  composites: {}
}

export type PathGetPayload<S extends boolean | null | undefined | PathDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$PathPayload, S>

export type PathCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<PathFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PathCountAggregateInputType | true
  }

export interface PathDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Path'], meta: { name: 'Path' } }
  /**
   * Find zero or one Path that matches the filter.
   * @param {PathFindUniqueArgs} args - Arguments to find a Path
   * @example
   * // Get one Path
   * const path = await prisma.path.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends PathFindUniqueArgs>(args: Prisma.SelectSubset<T, PathFindUniqueArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Path that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {PathFindUniqueOrThrowArgs} args - Arguments to find a Path
   * @example
   * // Get one Path
   * const path = await prisma.path.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends PathFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, PathFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Path that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathFindFirstArgs} args - Arguments to find a Path
   * @example
   * // Get one Path
   * const path = await prisma.path.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends PathFindFirstArgs>(args?: Prisma.SelectSubset<T, PathFindFirstArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Path that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathFindFirstOrThrowArgs} args - Arguments to find a Path
   * @example
   * // Get one Path
   * const path = await prisma.path.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends PathFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, PathFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Paths that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Paths
   * const paths = await prisma.path.findMany()
   * 
   * // Get first 10 Paths
   * const paths = await prisma.path.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const pathWithIdOnly = await prisma.path.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends PathFindManyArgs>(args?: Prisma.SelectSubset<T, PathFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Path.
   * @param {PathCreateArgs} args - Arguments to create a Path.
   * @example
   * // Create one Path
   * const Path = await prisma.path.create({
   *   data: {
   *     // ... data to create a Path
   *   }
   * })
   * 
   */
  create<T extends PathCreateArgs>(args: Prisma.SelectSubset<T, PathCreateArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Paths.
   * @param {PathCreateManyArgs} args - Arguments to create many Paths.
   * @example
   * // Create many Paths
   * const path = await prisma.path.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends PathCreateManyArgs>(args?: Prisma.SelectSubset<T, PathCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Paths and returns the data saved in the database.
   * @param {PathCreateManyAndReturnArgs} args - Arguments to create many Paths.
   * @example
   * // Create many Paths
   * const path = await prisma.path.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Paths and only return the `id`
   * const pathWithIdOnly = await prisma.path.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends PathCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, PathCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Path.
   * @param {PathDeleteArgs} args - Arguments to delete one Path.
   * @example
   * // Delete one Path
   * const Path = await prisma.path.delete({
   *   where: {
   *     // ... filter to delete one Path
   *   }
   * })
   * 
   */
  delete<T extends PathDeleteArgs>(args: Prisma.SelectSubset<T, PathDeleteArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Path.
   * @param {PathUpdateArgs} args - Arguments to update one Path.
   * @example
   * // Update one Path
   * const path = await prisma.path.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends PathUpdateArgs>(args: Prisma.SelectSubset<T, PathUpdateArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Paths.
   * @param {PathDeleteManyArgs} args - Arguments to filter Paths to delete.
   * @example
   * // Delete a few Paths
   * const { count } = await prisma.path.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends PathDeleteManyArgs>(args?: Prisma.SelectSubset<T, PathDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Paths.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Paths
   * const path = await prisma.path.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends PathUpdateManyArgs>(args: Prisma.SelectSubset<T, PathUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Paths and returns the data updated in the database.
   * @param {PathUpdateManyAndReturnArgs} args - Arguments to update many Paths.
   * @example
   * // Update many Paths
   * const path = await prisma.path.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Paths and only return the `id`
   * const pathWithIdOnly = await prisma.path.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends PathUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, PathUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Path.
   * @param {PathUpsertArgs} args - Arguments to update or create a Path.
   * @example
   * // Update or create a Path
   * const path = await prisma.path.upsert({
   *   create: {
   *     // ... data to create a Path
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Path we want to update
   *   }
   * })
   */
  upsert<T extends PathUpsertArgs>(args: Prisma.SelectSubset<T, PathUpsertArgs<ExtArgs>>): Prisma.Prisma__PathClient<runtime.Types.Result.GetResult<Prisma.$PathPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Paths.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathCountArgs} args - Arguments to filter Paths to count.
   * @example
   * // Count the number of Paths
   * const count = await prisma.path.count({
   *   where: {
   *     // ... the filter for the Paths we want to count
   *   }
   * })
  **/
  count<T extends PathCountArgs>(
    args?: Prisma.Subset<T, PathCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PathCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Path.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PathAggregateArgs>(args: Prisma.Subset<T, PathAggregateArgs>): Prisma.PrismaPromise<GetPathAggregateType<T>>

  /**
   * Group by Path.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PathGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends PathGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: PathGroupByArgs['orderBy'] }
      : { orderBy?: PathGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, PathGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPathGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Path model
 */
readonly fields: PathFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Path.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PathClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  fromRoom<T extends Prisma.RoomDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.RoomDefaultArgs<ExtArgs>>): Prisma.Prisma__RoomClient<runtime.Types.Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  toRoom<T extends Prisma.RoomDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.RoomDefaultArgs<ExtArgs>>): Prisma.Prisma__RoomClient<runtime.Types.Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  instructionSet<T extends Prisma.Path$instructionSetArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Path$instructionSetArgs<ExtArgs>>): Prisma.Prisma__InstructionSetClient<runtime.Types.Result.GetResult<Prisma.$InstructionSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  anchors<T extends Prisma.Path$anchorsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Path$anchorsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$PathAnchorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Path model
 */
export interface PathFieldRefs {
  readonly id: Prisma.FieldRef<"Path", 'String'>
  readonly fromRoomId: Prisma.FieldRef<"Path", 'String'>
  readonly toRoomId: Prisma.FieldRef<"Path", 'String'>
  readonly createdAt: Prisma.FieldRef<"Path", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Path", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Path findUnique
 */
export type PathFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter, which Path to fetch.
   */
  where: Prisma.PathWhereUniqueInput
}

/**
 * Path findUniqueOrThrow
 */
export type PathFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter, which Path to fetch.
   */
  where: Prisma.PathWhereUniqueInput
}

/**
 * Path findFirst
 */
export type PathFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter, which Path to fetch.
   */
  where?: Prisma.PathWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Paths to fetch.
   */
  orderBy?: Prisma.PathOrderByWithRelationInput | Prisma.PathOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Paths.
   */
  cursor?: Prisma.PathWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Paths from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Paths.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Paths.
   */
  distinct?: Prisma.PathScalarFieldEnum | Prisma.PathScalarFieldEnum[]
}

/**
 * Path findFirstOrThrow
 */
export type PathFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter, which Path to fetch.
   */
  where?: Prisma.PathWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Paths to fetch.
   */
  orderBy?: Prisma.PathOrderByWithRelationInput | Prisma.PathOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Paths.
   */
  cursor?: Prisma.PathWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Paths from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Paths.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Paths.
   */
  distinct?: Prisma.PathScalarFieldEnum | Prisma.PathScalarFieldEnum[]
}

/**
 * Path findMany
 */
export type PathFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter, which Paths to fetch.
   */
  where?: Prisma.PathWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Paths to fetch.
   */
  orderBy?: Prisma.PathOrderByWithRelationInput | Prisma.PathOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Paths.
   */
  cursor?: Prisma.PathWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Paths from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Paths.
   */
  skip?: number
  distinct?: Prisma.PathScalarFieldEnum | Prisma.PathScalarFieldEnum[]
}

/**
 * Path create
 */
export type PathCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * The data needed to create a Path.
   */
  data: Prisma.XOR<Prisma.PathCreateInput, Prisma.PathUncheckedCreateInput>
}

/**
 * Path createMany
 */
export type PathCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Paths.
   */
  data: Prisma.PathCreateManyInput | Prisma.PathCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Path createManyAndReturn
 */
export type PathCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * The data used to create many Paths.
   */
  data: Prisma.PathCreateManyInput | Prisma.PathCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Path update
 */
export type PathUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * The data needed to update a Path.
   */
  data: Prisma.XOR<Prisma.PathUpdateInput, Prisma.PathUncheckedUpdateInput>
  /**
   * Choose, which Path to update.
   */
  where: Prisma.PathWhereUniqueInput
}

/**
 * Path updateMany
 */
export type PathUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Paths.
   */
  data: Prisma.XOR<Prisma.PathUpdateManyMutationInput, Prisma.PathUncheckedUpdateManyInput>
  /**
   * Filter which Paths to update
   */
  where?: Prisma.PathWhereInput
  /**
   * Limit how many Paths to update.
   */
  limit?: number
}

/**
 * Path updateManyAndReturn
 */
export type PathUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * The data used to update Paths.
   */
  data: Prisma.XOR<Prisma.PathUpdateManyMutationInput, Prisma.PathUncheckedUpdateManyInput>
  /**
   * Filter which Paths to update
   */
  where?: Prisma.PathWhereInput
  /**
   * Limit how many Paths to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Path upsert
 */
export type PathUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * The filter to search for the Path to update in case it exists.
   */
  where: Prisma.PathWhereUniqueInput
  /**
   * In case the Path found by the `where` argument doesn't exist, create a new Path with this data.
   */
  create: Prisma.XOR<Prisma.PathCreateInput, Prisma.PathUncheckedCreateInput>
  /**
   * In case the Path was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.PathUpdateInput, Prisma.PathUncheckedUpdateInput>
}

/**
 * Path delete
 */
export type PathDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
  /**
   * Filter which Path to delete.
   */
  where: Prisma.PathWhereUniqueInput
}

/**
 * Path deleteMany
 */
export type PathDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Paths to delete
   */
  where?: Prisma.PathWhereInput
  /**
   * Limit how many Paths to delete.
   */
  limit?: number
}

/**
 * Path.instructionSet
 */
export type Path$instructionSetArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the InstructionSet
   */
  select?: Prisma.InstructionSetSelect<ExtArgs> | null
  /**
   * Omit specific fields from the InstructionSet
   */
  omit?: Prisma.InstructionSetOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.InstructionSetInclude<ExtArgs> | null
  where?: Prisma.InstructionSetWhereInput
}

/**
 * Path.anchors
 */
export type Path$anchorsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the PathAnchor
   */
  select?: Prisma.PathAnchorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the PathAnchor
   */
  omit?: Prisma.PathAnchorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathAnchorInclude<ExtArgs> | null
  where?: Prisma.PathAnchorWhereInput
  orderBy?: Prisma.PathAnchorOrderByWithRelationInput | Prisma.PathAnchorOrderByWithRelationInput[]
  cursor?: Prisma.PathAnchorWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.PathAnchorScalarFieldEnum | Prisma.PathAnchorScalarFieldEnum[]
}

/**
 * Path without action
 */
export type PathDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Path
   */
  select?: Prisma.PathSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Path
   */
  omit?: Prisma.PathOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.PathInclude<ExtArgs> | null
}
